## 패턴 돌아보기

| 패턴         | 범주 | 대상  | 설명                                      |
|------------|----|-----|-----------------------------------------|
| 싱글턴 패턴     | 생성 | 객체  | 하나의 인스턴스만 생성하도록 제한.                     |
| 팩토리 패턴     | 생성 | 클래스 | 객체 생성 로직을 별도의 팩토리 클래스에 캡슐화.             |
| 어댑터 패턴     | 구조 | 객체  | 호환되지 않는 인터페이스를 맞춰 사용 가능하게 변환.           |
| 데코레이터 패턴   | 구조 | 객체  | 객체에 동적으로 기능을 추가할 때 사용.                  |
| 퍼사드 패턴     | 구조 | 객체  | 복잡한 시스템을 단순화하여 단일 인터페이스 제공.             |
| 프록시 패턴     | 구조 | 객체  | 접근 제어나 추가 기능 제공을 위해 객체 대리자 제공.          |
| 컴포지트 패턴    | 구조 | 객체  | 객체들을 트리 구조로 구성해 부분-전체 계층 표현.            |
| 옵저버 패턴     | 행동 | 객체  | 객체 상태 변화를 감지해 자동으로 다른 객체에 알림.           |
| 커맨드 패턴     | 행동 | 객체  | 실행할 작업을 캡슐화하여 호출자와 수신자 분리.              |
| 반복자 패턴     | 행동 | 객체  | 객체 컬렉션을 순차적으로 접근하는 방법 제공.               |
| 템플릿 메소드 패턴 | 행동 | 클래스 | 상위 클래스에서 알고리즘의 뼈대를 정의하고 하위 클래스에서 세부 구현. |
| 상태 패턴      | 행동 | 객체  | 객체 상태에 따라 다른 동작을 수행하도록 상태를 객체화.         |

### 디자인 패턴 범주

- 생성 패턴 (Creation Pattern): 객체 인스턴스와 클라이언트 간의 결합도를 낮추어 유연성을 높입니다.
- 구조 패턴 (Structural Pattern): 클래스와 객체를 더 큰 구조로 결합하여 확장성을 제공합니다.
- 행동 패턴 (Behavioral Pattern): 클래스와 객체 간의 상호작용 및 역할 분담 방식을 정의합니다.

### 대상별 분류

- 클래스 패턴(Class Pattern): 클래스 사이의 관계가 상속으로 어떻게 정의되는지, 주로 컴파일타임에서 결정
- 객체 패턴(Object Pattern): 객체 사이의 관계를 다루며, 주로 런타임에서 결정

## 패턴의 구조

> 패턴(pattern)은 특정 컨텍스트 내에서 주어진 문제의 해결책이다.

- 컨텍스트(context): 패턴이 적용되는 상황
- 문제(problem): 컨텍스트 내에서 이뤄야 하는 목표
- 해결책(solution): 제약조건 속에서 누가 적용해도 목표를 이룰 수 있는 일반적인 디자인

## 패턴 분석 예문

```예문
- 컨텍스트
  - 객체들의 컬렉션이 주어져 있습니다.
- 문제
  - 컬렉션의 구현을 드러내지 않으면서 그 안에 있는 각 객체를 대상으로 순환 작업을 할 수 있어야 합니다.
- 해결책
  - 반복 작업을 별도의 클래스로 캡슐화 합니다. (반복자 패턴)
```

## 패턴의 제약사항

컨텍스트가 반복적으로 발생하며, **일반화된 방법**으로 **문제**를 해결할 수 있어야합니다.

핵심 키워드: "반복"

> 잘못된 패턴의 예시
>  - 컨텍스트: 차에 자동차 열쇠를 두고 나왔는데 문이 잠겼다.
>  - 문제: 어떻게 회사에 제시간에 도착할 것인가?
>  - 해결책: 유리를 깬다. 차에 들어간다. 차를 몰고 출근한다.
>
> 가끔 정신을 팔다보면 열쇠를 차안에 두고 내릴순 있으나, 유리를 깨는 방법은 반복적으로 적용할 수 없다.
> 혹여나 반복이 되더라도, 비용이라는 또다른 제약조건을 벗어날 수 없다...
>

## 개인적인 의견

잘못된 추상화의 예시가 패턴 분석의 부재 혹은 오류에서 비롯된게 아닐까요...

패턴이 존재하지 않는다면, 굳이 디자인 패턴을 적용할 필요가 없습니다.

## 패턴의 이름을 정의하고 카테고리화 하는 이유

우리는 같이 일을 해야한다. 이름이 없다면 그 디자인 패턴에 대해 논의하기 힘들어집니다.

디자인 패턴에 대한 카탈로그를 정리하는 것이 좋습니다.

- 패턴 이름
- 용도 (Intent): 패턴의 역할 정의
- 동기 (Motivation): 문제(problem)를 기술
- 적용 대상 (Adaptation): 그 패턴을 적용할 수 있는 상황(context)
- 구조 (structure), 구성 요소(participant), 협동(collaboration), 결과(consequences), 구현(Implementation), 샘플코드(sample code), 사용 예(
  known uses), 연관 패턴(related pattern) ...

요런 카탈로그 형식으로 블로그 포스팅을 해보면...?! (605 page)

## 리팩토링과 패턴

리팩터링이란 코드를 변경해서 코드 구조를 개선하는 과정을 뜻합니다. 리팩토링의 목적은 행동 변경이 아니라, **구조 개선**에 있습니다.

리팩터링 과정에서 디자인 패턴을 통해 구조가 개선될 수 있다면 적용하세요.

> ‼️꼭 필요하지 않은 패턴은 제거하기 / 미리 적용하지 않기

